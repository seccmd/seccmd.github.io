import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,f as o,o as c}from"./app-BW5LY_Xg.js";const r={};function n(s,t){return c(),e("div",null,[...t[0]||(t[0]=[o('<h1 id="linux-cmd" tabindex="-1"><a class="header-anchor" href="#linux-cmd"><span>Linux CMD</span></a></h1><p>挑战最长度：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">coproc builtin command eval  exec setsid echo 123456 &gt; /tmp/ls.txt</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>以下是 Bash 中用于执行命令或程序的相关方法列表，按类别和功能分类整理：</p><hr><h3 id="bash-命令-程序执行方式列表" tabindex="-1"><a class="header-anchor" href="#bash-命令-程序执行方式列表"><span><strong>Bash 命令/程序执行方式列表</strong></span></a></h3><table><thead><tr><th><strong>类别</strong></th><th><strong>命令/语法</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>直接执行</strong></td><td><code>command</code></td><td>直接运行命令（默认行为，受别名/函数影响）</td><td><code>ls</code></td></tr><tr><td><strong>绕过干扰</strong></td><td><code>\\command</code></td><td>忽略别名（同<code>command command</code>）</td><td><code>\\ls</code></td></tr><tr><td></td><td><code>command command</code></td><td>绕过别名和函数，直接调用原始命令或外部命令</td><td><code>command ls</code></td></tr><tr><td></td><td><code>builtin command</code></td><td>强制调用内置命令（忽略同名函数/外部命令）</td><td><code>builtin echo &quot;Hello&quot;</code></td></tr><tr><td><strong>进程控制</strong></td><td><code>exec command</code></td><td>用<code>command</code> 替换当前 Shell 进程（执行后退出 Shell）</td><td><code>exec bash</code></td></tr><tr><td><strong>动态执行</strong></td><td><code>eval &quot;string&quot;</code></td><td>将字符串作为命令执行（可解析变量/转义符）</td><td><code>eval &quot;echo \\$USER&quot;</code></td></tr><tr><td><strong>子 Shell</strong></td><td><code>(commands)</code></td><td>在子 Shell 中执行命令组（不改变当前环境）</td><td><code>(cd /tmp &amp;&amp; ls)</code></td></tr><tr><td></td><td><code>$(commands)</code></td><td>在子 Shell 执行命令并捕获输出</td><td><code>files=$(ls)</code></td></tr><tr><td><strong>协程/后台</strong></td><td><code>coproc</code></td><td>创建协程（异步后台进程，可双向通信）</td><td><code>coproc myproc { sleep 10; }</code></td></tr><tr><td><strong>脱离终端</strong></td><td><code>setsid command</code></td><td>在新会话中运行命令（脱离终端控制）</td><td><code>setsid long_running_task</code></td></tr><tr><td></td><td><code>nohup command</code></td><td>忽略挂断信号（SSH 断开后仍运行）</td><td><code>nohup ./script.sh &amp;</code></td></tr><tr><td><strong>条件执行</strong></td><td><code>cmd1 &amp;&amp; cmd2</code></td><td><code>cmd1</code>成功时执行<code>cmd2</code></td><td><code>mkdir dir &amp;&amp; cd dir</code></td></tr><tr><td></td><td>`cmd1</td><td>cmd2`</td><td><code>cmd1</code>失败时执行<code>cmd2</code></td></tr><tr><td><strong>外部工具</strong></td><td><code>xargs</code></td><td>将输入转换为命令参数</td><td>`echo &quot;1 2&quot;</td></tr><tr><td></td><td><code>find -exec</code></td><td>对查找结果执行命令</td><td><code>find . -name &quot;*.txt&quot; -exec rm {} \\;</code></td></tr></tbody></table><hr><p>以下是 Bash 历史扩展（<code>!</code>命令）的 <strong>常用变体</strong> 及其用途的完整总结，涵盖高效操作和历史命令复用的技巧：</p><hr><h2 id="_1-基础历史命令调用" tabindex="-1"><a class="header-anchor" href="#_1-基础历史命令调用"><span><strong>1. 基础历史命令调用</strong></span></a></h2><table><thead><tr><th>变体</th><th>作用</th><th>示例（假设上条命令是<code>ls /tmp/file.txt</code>）</th></tr></thead><tbody><tr><td><code>!!</code></td><td><strong>执行上一条命令</strong></td><td><code>sudo !!</code>→<code>sudo ls /tmp/file.txt</code></td></tr><tr><td><code>!-n</code></td><td>执行前第<code>n</code> 条命令（从当前倒数）</td><td><code>!-2</code> → 执行倒数第二条命令</td></tr><tr><td><code>!n</code></td><td>执行历史记录中编号为<code>n</code> 的命令</td><td><code>!100</code> → 执行编号 100 的命令</td></tr><tr><td><code>!string</code></td><td>执行最近以<code>string</code> 开头的命令</td><td><code>!ls</code>→ 执行最近的<code>ls ...</code></td></tr></tbody></table><hr><h2 id="_2-参数引用-避免重复输入路径-参数" tabindex="-1"><a class="header-anchor" href="#_2-参数引用-避免重复输入路径-参数"><span><strong>2. 参数引用（避免重复输入路径/参数）</strong></span></a></h2><table><thead><tr><th>变体</th><th>作用</th><th>示例（上条命令：<code>cat /var/log/syslog</code>）</th></tr></thead><tbody><tr><td><code>!$</code></td><td><strong>上条命令的最后一个参数</strong></td><td><code>vim !$</code>→<code>vim /var/log/syslog</code></td></tr><tr><td><code>!^</code></td><td>上条命令的第一个参数</td><td><code>cp !^ ~/backup</code>→<code>cp /var/log ~/backup</code></td></tr><tr><td><code>!*</code></td><td>上条命令的所有参数（除命令名）</td><td><code>grep &quot;error&quot; !*</code>→<code>grep &quot;error&quot; /var/log/syslog</code></td></tr><tr><td><code>!:n</code></td><td>上条命令的第<code>n</code> 个参数（从 0 开始）</td><td><code>echo !:1</code>→<code>echo /var/log</code></td></tr></tbody></table><hr><h2 id="_3-快速修改历史命令" tabindex="-1"><a class="header-anchor" href="#_3-快速修改历史命令"><span><strong>3. 快速修改历史命令</strong></span></a></h2><table><thead><tr><th>变体</th><th>作用</th><th>示例（上条命令：<code>echo hello world</code>）</th></tr></thead><tbody><tr><td><code>!!:s/old/new</code></td><td>替换上条命令中的第一个<code>old</code>为<code>new</code></td><td><code>!!:s/hello/Hi</code>→<code>echo Hi world</code></td></tr><tr><td><code>!!:gs/old/new</code></td><td>替换上条命令中所有<code>old</code>为<code>new</code></td><td><code>!!:gs/o/O</code>→<code>echO hellO wOrld</code></td></tr><tr><td><code>!!:p</code></td><td><strong>仅打印上条命令，不执行</strong></td><td><code>!!:p</code>→ 显示<code>echo hello world</code></td></tr></tbody></table><hr><table><thead><tr><th><strong>场景</strong></th><th><strong>变体</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>重复上条命令</td><td><code>!!</code></td><td><code>sudo !!</code></td></tr><tr><td>最后一个参数</td><td><code>!$</code></td><td><code>vim !$</code></td></tr><tr><td>第一个参数</td><td><code>!^</code></td><td><code>chmod +x !^</code></td></tr><tr><td>所有参数</td><td><code>!*</code></td><td><code>grep &quot;error&quot; !*</code></td></tr><tr><td>替换命令中的字符串</td><td><code>!!:s/old/new</code></td><td><code>!!:s/cat/less</code></td></tr><tr><td>仅打印不执行</td><td><code>!!:p</code></td><td><code>!!:p</code> → 显示命令</td></tr><tr><td>搜索历史命令</td><td><code>!?keyword</code></td><td><code>!?nginx</code></td></tr></tbody></table><p>掌握这些变体能极大提升命令行效率，但需谨慎操作历史中的敏感命令！</p>',21)])])}const i=d(r,[["render",n]]),l=JSON.parse('{"path":"/sec/rednote/onekey/linuxcmd.html","title":"Linux  CMD","lang":"zh-CN","frontmatter":{"description":"Linux CMD 挑战最长度： 以下是 Bash 中用于执行命令或程序的相关方法列表，按类别和功能分类整理： Bash 命令/程序执行方式列表 以下是 Bash 历史扩展（!命令）的 常用变体 及其用途的完整总结，涵盖高效操作和历史命令复用的技巧： 1. 基础历史命令调用 2. 参数引用（避免重复输入路径/参数） 3. 快速修改历史命令 掌握这些变体...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Linux  CMD\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-22T13:54:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"SecCMD\\",\\"url\\":\\"https://www.seccmd.net\\"}]}"],["meta",{"property":"og:url","content":"https://www.seccmd.net/sec/rednote/onekey/linuxcmd.html"}],["meta",{"property":"og:site_name","content":"明剑实验室"}],["meta",{"property":"og:title","content":"Linux  CMD"}],["meta",{"property":"og:description","content":"Linux CMD 挑战最长度： 以下是 Bash 中用于执行命令或程序的相关方法列表，按类别和功能分类整理： Bash 命令/程序执行方式列表 以下是 Bash 历史扩展（!命令）的 常用变体 及其用途的完整总结，涵盖高效操作和历史命令复用的技巧： 1. 基础历史命令调用 2. 参数引用（避免重复输入路径/参数） 3. 快速修改历史命令 掌握这些变体..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-22T13:54:52.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-22T13:54:52.000Z"}]]},"git":{"createdTime":1758549292000,"updatedTime":1758549292000,"contributors":[{"name":"fireadm","username":"fireadm","email":"iwanwu@hotmail.com","commits":1,"url":"https://github.com/fireadm"}]},"readingTime":{"minutes":2.6,"words":780},"filePathRelative":"sec/rednote/onekey/linuxcmd.md","autoDesc":true}');export{i as comp,l as data};
